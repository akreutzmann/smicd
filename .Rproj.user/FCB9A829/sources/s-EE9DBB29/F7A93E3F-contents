#
# The algorithm is adjusted for Aquivalenzgewichte
#


dclassMicro <- function(data, burnin = 5, samples = 20, evalpoints = 4000) {

# Estimate Midpoints
data$Mid <- 1/2 * (data$UBadj + data$LBadj)

# Estimate Gridpoints
gridx = seq(min(data$LBadj), max(data$UBadj), length = evalpoints)


Mestimates <- density(data$Mid, from = min(gridx), to = max(gridx), 
                      n = length(gridx), bw = 2 * max(data$UBadj)/
                        length(unique(data$NIntervals)))$y

resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(data$Mid))

mean <- NULL
gin <- NULL
hcr <- NULL
quant10 <- NULL
quant25 <- NULL
quant50 <- NULL
quant75 <- NULL
quant90 <- NULL
pgap <- NULL
qsr <- NULL

for (j in 1:(burnin + samples)) {
  new = c()
  EstDat = matrix(ncol = 2, nrow = nrow(data))
  newWeights = c()
  for (i in 1:(length(unique(data$NIntervals)))) {
    
    dataTemp <- data[data$NIntervals == unique(data$NIntervals)[i],]
    LBTemp <- unique(dataTemp$LBadj)
    UBTemp <- unique(dataTemp$UBadj)
    selectionGrid <- gridx[gridx >= LBTemp & gridx < UBTemp]
    newWeights <-c(newWeights, dataTemp$Weight)
    
    probs = as.vector(Mestimates[gridx%in%selectionGrid])
    points = gridx[gridx%in%selectionGrid]
    npoints = nrow(dataTemp)
    new = c(new, points[sample(1:length(points), size = npoints, 
                               replace = T, prob = probs)])
    
  }
  
  NewDensity <- density(new, from = min(gridx), to = max(gridx), 
                        n = length(gridx), bw = "nrd0", adjust = 1)
  Mestimates <- NewDensity$y
  
  resultDensity[, j] = Mestimates
  resultX[, j] = new
  EstDat[,1] <- new
  EstDat[,2] <- newWeights
  
  # Hier gleich die Punktschaetzer mit dem Laekenpaket berechnen
  mean <- c(mean, weighted.mean(EstDat[,1], w = EstDat[,2]))
  gin <-  c(gin, (gini(EstDat[,1], weights = EstDat[,2])$value)/100)
  hcr <-  c(hcr, (arpr(EstDat[,1], weights = EstDat[,2], p = 0.6)$value)/100)
  quant10 <-  c(quant10, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.1)))
  quant25 <-  c(quant25, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.25)))
  quant50 <-  c(quant50, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.5)))
  quant75 <-  c(quant75, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.75)))
  quant90 <-  c(quant90, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.9)))
  sw <- sum(EstDat[,2])
  threshold <-  0.6 * weighted.quantile(EstDat[,1], 
                                        w = EstDat[,2],
                                        probs = .5)
  pgap <- c(pgap,sum(EstDat[,2] * (EstDat[,1] < threshold) * (threshold - EstDat[,1]) 
                     / threshold) / sw )
  qsr <- c(qsr, qsr(EstDat[,1], weights = EstDat[,2])$value)
  print(paste("Iteration:", j, "of", burnin + samples))
}

Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
est <- list(Mestimates = Mestimates, resultDensity = resultDensity, 
            resultX = resultX,  gridx = gridx, 
            burnin = burnin, samples = samples, mean = mean, gini = gin,
            hcr = hcr, quant10 = quant10, quant25 = quant25, quant50 = quant50,
            quant75 = quant75, quant90 = quant90, pgap = pgap, qsr = qsr) 
return(est)
}
