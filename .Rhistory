selectionGrid <- gridx[gridx >= LBTemp & gridx < UBTemp]
newWeights <-c(newWeights, dataTemp$weights)
probs = as.vector(Mestimates[gridx%in%selectionGrid])
points = gridx[gridx%in%selectionGrid]
npoints = nrow(dataTemp)
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = "nrd0", adjust = 1)
Mestimates <- NewDensity$y
resultDensity[, j] = Mestimates
resultX[, j] = new
if(is.null(weights)){resultW <- NULL} else {
resultW[,j] = newWeights}
}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
}
est <- list(Mestimates = Mestimates, resultDensity = resultDensity,
resultX = resultX, xclass = xclass, gridx = gridx, classes = classes,
burnin = burnin, samples = samples, resultW = resultW)
return(est)
}
if (bootstrap.se==TRUE) {
Standard.Error <- standardError.est(b = b, xclass = xclass,
classes = classes, burnin = burnin,
samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust,
threshold = threshold,
custom_indicator = custom_indicator, upper = upper,
weights = weights, oecd = oecd)
}
# Internal documentation -------------------------------------------------------
# The function estimates the pre-defined indicators
indicators.est <- function(x,threshold, custom_indicator, weights) {
if (is.null(weights)) {
if(is.na(threshold)) {
threshold <- 0.6*median(x)
} else {
threshold <- threshold*median(x)
}
results <- c(mean = mean(x),
gini = ineq(x),
hcr = mean(x<threshold),
quant10 = unname(quantile(x, probs = c(0.1))),
quant25 = unname(quantile(x, probs = c(0.25))),
quant50 = unname(quantile(x, probs = c(0.50))),
quant75 = unname(quantile(x, probs = c(0.75))),
quant90 = unname(quantile(x, probs = c(0.90))) ,
pgap = mean((x<threshold)*(threshold-x)/threshold),
qsr = sum(x[(x>quantile(x,0.8))])/sum(x[(x<quantile(x,0.2))])
)
if (!is.null(custom_indicator)){
c.indicator <- NULL
for(i in 1:length(custom_indicator)) {
c.indicator <- c(c.indicator, custom_indicator[[i]](x, threshold))
}
names(c.indicator) <- names(custom_indicator)
results <- c(results, c.indicator)
}
} else {
sw <- sum(weights)
thresholdW <-  threshold * weighted.quantile(x,
w = weights,
probs = .5)
results <- c(mean = weighted.mean(x, w = weights),
gini =  gini(x, weights = weights)$value/100,
hcr =  arpr(x, weights = weights, p = threshold)$value/100,
quant10 =  unname(weighted.quantile(x, w = weights, probs = 0.1)),
quant25 =  unname(weighted.quantile(x, w = weights, probs = 0.25)),
quant50 =  unname(weighted.quantile(x, w = weights, probs = 0.5)),
quant75 =  unname(weighted.quantile(x, w = weights, probs = 0.75)),
quant90 =  unname(weighted.quantile(x, w = weights, probs = 0.9)),
pgap = sum(weights * (x < thresholdW) * (thresholdW - x)
/ thresholdW) / sw,
qsr = qsr(x, weights = weights)$value)
if (!is.null(custom_indicator)){
c.indicator <- NULL
for(i in 1:length(custom_indicator)) {
c.indicator <- c(c.indicator, custom_indicator[[i]](x, threshold, weights))
}
names(c.indicator) <- names(custom_indicator)
results <- c(results, c.indicator)
}
}
return(results)
}
results.kernel <- NULL
i<-1
boot_samp <- xclass[sample(length(xclass), size=length(xclass), replace = TRUE)]
capture.output(densityEst <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust, upper = upper,
weights= weights, oecd = oecd))
results.kernel <- rbind(results.kernel, rowMeans(apply(densityEst$resultX[,-c(1:burnin)],2,
function(x) {indicators.est(x,threshold,
custom_indicator)})))
weights
Indicators.run <- NULL
Indicators.run <- NULL
for (j in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust, upper = upper,
weights= weights, oecd = oecd)
Indicators.run <- NULL
for (j in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
Indicators <- rowMeans(Indicators.run)
Indicators
results.kernel <- rbind(result.kernel,rowMeans(Indicators.run))
results.kernel <- NULL
for (i in 1:b) {
Sys.sleep(0.1)
boot_samp <- xclass[sample(length(xclass), size=length(xclass), replace = TRUE)]
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust, upper = upper,
weights= weights, oecd = oecd)
#results.kernel <- rbind(results.kernel, rowMeans(apply(densityEst$resultX[,-c(1:burnin)],2,
#                                                      function(x) {indicators.est(x,threshold,
#                                                                                   custom_indicator)})))
Indicators.run <- NULL
for (j in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
results.kernel <- rbind(result.kernel,rowMeans(Indicators.run))
setTxtProgressBar(pb, i)
}
results.kernel <- NULL
for (i in 1:b) {
Sys.sleep(0.1)
boot_samp <- xclass[sample(length(xclass), size=length(xclass), replace = TRUE)]
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust, upper = upper,
weights= weights, oecd = oecd)
#results.kernel <- rbind(results.kernel, rowMeans(apply(densityEst$resultX[,-c(1:burnin)],2,
#                                                      function(x) {indicators.est(x,threshold,
#                                                                                   custom_indicator)})))
Indicators.run <- NULL
for (j in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
results.kernel <- rbind(results.kernel,rowMeans(Indicators.run))
setTxtProgressBar(pb, i)
}
results.kernel
i
b
pb <- txtProgressBar(min = 1, max = b, style = 3)
results.kernel <- NULL
for (i in 1:b) {
Sys.sleep(0.1)
boot_samp <- xclass[sample(length(xclass), size=length(xclass), replace = TRUE)]
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust, upper = upper,
weights= weights, oecd = oecd)
#results.kernel <- rbind(results.kernel, rowMeans(apply(densityEst$resultX[,-c(1:burnin)],2,
#                                                      function(x) {indicators.est(x,threshold,
#                                                                                   custom_indicator)})))
Indicators.run <- NULL
for (j in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
results.kernel <- rbind(results.kernel,rowMeans(Indicators.run))
setTxtProgressBar(pb, i)
}
se.boot <- apply(results.kernel,2,function(x){sqrt(mean((x-mean(x))^2))})
se.boot
results.kernel
str(results.kernel)
str(results)
Standard.Error = NULL
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary,
bw = bw, evalpoints = evalpoints, adjust = adjust,
upper = upper, weights = weights, oecd = oecd)
Indicators.run <- NULL
for (i in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
Indicators <- rowMeans(Indicators.run)
if (bootstrap.se==TRUE) {
Standard.Error <- standardError.est(b = b, xclass = xclass,
classes = classes, burnin = burnin,
samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust,
threshold = threshold,
custom_indicator = custom_indicator, upper = upper,
weights = weights, oecd = oecd)
}
results <- list(Point_estimate = Indicators, Standard_Error = Standard.Error,
Mestimates = density.est$Mestimates,
resultDensity = density.est$resultDensity,
resultX = density.est$resultX,
xclass = xclass, gridx = density.est$gridx,
classes = classes, burnin = burnin,
samples = samples, Point_estimate.run = Indicators.run,
oecd = oecd, weights = weights)
bootstrap.se==TRUE)
(bootstrap.se==TRUE)
weights
Standard.Error <- standardError.est(b = b, xclass = xclass,
classes = classes, burnin = burnin,
samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust,
threshold = threshold,
custom_indicator = custom_indicator, upper = upper,
weights = weights, oecd = oecd)
density.est$resultW
ensity.est$resultW[,i]
density.est$resultW[,i]
load("C:/Users/Paul/Desktop/kdeCheck.RData")
bootstrap.se = TRUE
b = 5
Standard.Error = NULL
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary,
bw = bw, evalpoints = evalpoints, adjust = adjust,
upper = upper, weights = weights, oecd = oecd)
# Internal documentation -------------------------------------------------------
#
# dclassICD
dclassICD <- function (xclass, classes, burnin, samples, boundary,
bw, evalpoints, adjust, upper, weights, oecd){
if(is.null(oecd)){
xclassF <- xclass
if (max(classes) == Inf) {
classes[length(classes)] = upper * classes[length(classes) -
1]
}
classmeans <- sapply(1:(length(classes) - 1), function(x) 1/2 *
(classes[x + 1] + classes[x]))
levels(xclass) <- classmeans
lengths = as.vector(table(xclass))
xclass <- as.numeric(as.character(xclass))
gridx = seq(min(classes), max(classes), length = evalpoints)
if (boundary == FALSE) {
Mestimates <- density(xclass, from = min(gridx), to = max(gridx),
n = length(gridx), bw = 2 * max(classes)/length(classes))$y
}
if (boundary == TRUE) {
Mestimates <- dbc(gridx = gridx, x = xclass, bw = 2 *
max(classes)/length(classes))
}
resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(xclass))
resultW = matrix(ncol = c(burnin + samples), nrow = length(xclass))
selectionGrid <- lapply(1:(length(classes) - 1), function(k) {
selection = which(gridx >= classes[k] & gridx < classes[k +
1])
selection
})
if(!is.null(weights)){data <- cbind(xclassF,weights)}
for (j in 1:(burnin + samples)) {
new = c()
newW = c()
for (i in 1:(length(classes) - 1)) {
probs = as.vector(Mestimates[selectionGrid[[i]]])
points = gridx[selectionGrid[[i]]]
npoints = lengths[i]
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
if(!is.null(weights)){newW = c(newW,  data[data[,1]==i,][,2])}
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = bw, adjust = adjust)
Mestimates <- NewDensity$y
if (boundary == TRUE) {
Mestimates <- dbc(gridx = gridx, x = new, bw = NewDensity$bw)
}
resultDensity[,j] = Mestimates
resultX[,j] = new
if(!is.null(weights)){resultW[,j] = newW}
}
if (is.null(weights)){resultW <- NULL}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
} else {
if(is.null(weights)) {weights <- rep(1,length(xclass))}
data <- cbind(xclass, weights, oecd)
LB <- NULL
UB <- NULL
for(i in 1:nrow(data)) {
LB <- c(LB,classes[data[i,1]])
UB <- c(UB,classes[data[i,1]+1])
}
data <- data.frame(xclass, weights, oecd, LB, UB)
data$UB[data$UB == Inf] <- upper * classes[length(classes)-1]
data$LBadj <- data$LB/data$oecd
data$UBadj <- data$UB/data$oecd
data$NIntervals <- paste0(round(data$LBadj, digits = 0), round(data$UBadj,
digits = 0))
data$Mid <- 1/2 * (data$UBadj + data$LBadj)
gridx = seq(min(data$LBadj), max(data$UBadj), length = evalpoints)
Mestimates <- density(data$Mid, from = min(gridx), to = max(gridx),
n = length(gridx), bw = 2 * max(data$UBadj)/
length(unique(data$NIntervals)))$y
resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(data$Mid))
resultW = matrix(ncol = c(burnin + samples), nrow = length(xclass))
for (j in 1:(burnin + samples)) {
new = c()
EstDat = matrix(ncol = 2, nrow = nrow(data))
newWeights = c()
for (i in 1:(length(unique(data$NIntervals)))) {
dataTemp <- data[data$NIntervals == unique(data$NIntervals)[i],]
LBTemp <- unique(dataTemp$LBadj)
UBTemp <- unique(dataTemp$UBadj)
selectionGrid <- gridx[gridx >= LBTemp & gridx < UBTemp]
newWeights <-c(newWeights, dataTemp$weights)
probs = as.vector(Mestimates[gridx%in%selectionGrid])
points = gridx[gridx%in%selectionGrid]
npoints = nrow(dataTemp)
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = "nrd0", adjust = 1)
Mestimates <- NewDensity$y
resultDensity[, j] = Mestimates
resultX[, j] = new
if(is.null(weights)){resultW <- NULL} else {
resultW[,j] = newWeights}
}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
}
est <- list(Mestimates = Mestimates, resultDensity = resultDensity,
resultX = resultX, xclass = xclass, gridx = gridx, classes = classes,
burnin = burnin, samples = samples, resultW = resultW)
return(est)
}
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary,
bw = bw, evalpoints = evalpoints, adjust = adjust,
upper = upper, weights = weights, oecd = oecd)
Indicators.run <- NULL
for (i in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
# Internal documentation -------------------------------------------------------
# The function estimates the pre-defined indicators
indicators.est <- function(x,threshold, custom_indicator, weights) {
if (is.null(weights)) {
if(is.na(threshold)) {
threshold <- 0.6*median(x)
} else {
threshold <- threshold*median(x)
}
results <- c(mean = mean(x),
gini = ineq(x),
hcr = mean(x<threshold),
quant10 = unname(quantile(x, probs = c(0.1))),
quant25 = unname(quantile(x, probs = c(0.25))),
quant50 = unname(quantile(x, probs = c(0.50))),
quant75 = unname(quantile(x, probs = c(0.75))),
quant90 = unname(quantile(x, probs = c(0.90))) ,
pgap = mean((x<threshold)*(threshold-x)/threshold),
qsr = sum(x[(x>quantile(x,0.8))])/sum(x[(x<quantile(x,0.2))])
)
if (!is.null(custom_indicator)){
c.indicator <- NULL
for(i in 1:length(custom_indicator)) {
c.indicator <- c(c.indicator, custom_indicator[[i]](x, threshold))
}
names(c.indicator) <- names(custom_indicator)
results <- c(results, c.indicator)
}
} else {
sw <- sum(weights)
thresholdW <-  threshold * weighted.quantile(x,
w = weights,
probs = .5)
results <- c(mean = weighted.mean(x, w = weights),
gini =  gini(x, weights = weights)$value/100,
hcr =  arpr(x, weights = weights, p = threshold)$value/100,
quant10 =  unname(weighted.quantile(x, w = weights, probs = 0.1)),
quant25 =  unname(weighted.quantile(x, w = weights, probs = 0.25)),
quant50 =  unname(weighted.quantile(x, w = weights, probs = 0.5)),
quant75 =  unname(weighted.quantile(x, w = weights, probs = 0.75)),
quant90 =  unname(weighted.quantile(x, w = weights, probs = 0.9)),
pgap = sum(weights * (x < thresholdW) * (thresholdW - x)
/ thresholdW) / sw,
qsr = qsr(x, weights = weights)$value)
if (!is.null(custom_indicator)){
c.indicator <- NULL
for(i in 1:length(custom_indicator)) {
c.indicator <- c(c.indicator, custom_indicator[[i]](x, threshold, weights))
}
names(c.indicator) <- names(custom_indicator)
results <- c(results, c.indicator)
}
}
return(results)
}
Indicators.run <- NULL
for (i in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
Indicators <- rowMeans(Indicators.run)
(bootstrap.se==TRUE)
results.kernel <- NULL
i<-1
Sys.sleep(0.1)
boot_samp <- xclass[sample(length(xclass), size=length(xclass), replace = TRUE)]
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust, upper = upper,
weights= weights, oecd = oecd)
Indicators.run <- NULL
if (bootstrap.se==TRUE) {
Standard.Error <- standardError.est(b = b, xclass = xclass,
classes = classes, burnin = burnin,
samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust,
threshold = threshold,
custom_indicator = custom_indicator, upper = upper,
weights = weights, oecd = oecd)
}
# Internal documentation -------------------------------------------------------
# The function estimates the standard errors of the indicators
standardError.est <- function(b, xclass, classes, burnin, samples, boundary, bw, evalpoints, adjust, threshold,
custom_indicator, upper, weights, oecd){
pb <- txtProgressBar(min = 1, max = b, style = 3)
results.kernel <- NULL
for (i in 1:b) {
Sys.sleep(0.1)
boot_samp <- xclass[sample(length(xclass), size=length(xclass), replace = TRUE)]
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust, upper = upper,
weights= weights, oecd = oecd)
Indicators.run <- NULL
for (j in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,j],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,j]))
}
results.kernel <- rbind(results.kernel,rowMeans(Indicators.run))
setTxtProgressBar(pb, i)
}
se.boot <- apply(results.kernel,2,function(x){sqrt(mean((x-mean(x))^2))})
return(se.boot)
}
if (bootstrap.se==TRUE) {
Standard.Error <- standardError.est(b = b, xclass = xclass,
classes = classes, burnin = burnin,
samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust,
threshold = threshold,
custom_indicator = custom_indicator, upper = upper,
weights = weights, oecd = oecd)
}
results <- list(Point_estimate = Indicators, Standard_Error = Standard.Error,
Mestimates = density.est$Mestimates,
resultDensity = density.est$resultDensity,
resultX = density.est$resultX,
xclass = xclass, gridx = density.est$gridx,
classes = classes, burnin = burnin,
samples = samples, Point_estimate.run = Indicators.run,
oecd = oecd, weights = weights)
str(results)
help("kdeAlgo")
library(ICD)
example("kdeAlgo")
library(ICD)
install.packages("roxygen2")
library(ICD)
Exam
head(Exam)
load(Exa,)
load(Exam)
data <- Exa,
data <- Exam
library(ICD)
help("kdeAlgo")
data <- Exa,
data <- Exam
?weights
installed.packages("mlmRev")
install.packages("mlmRev")
install.packages("Kernelheaping")
library(ICD)
