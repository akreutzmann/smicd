Mestimates <- NewDensity$y
if (boundary == TRUE) {
Mestimates <- dbc(gridx = gridx, x = new, bw = NewDensity$bw)
}
resultDensity[,j] = Mestimates
resultX[,j] = new
if(!is.null(weights)){resultW[,j] = newW}
}
if (is.null(weights)){resultW <- NULL}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
} else {
if(is.null(weights)) {weights <- rep(1,length(xclass))}
data <- cbind(xclass, weights, oecd)
LB <- NULL
UB <- NULL
for(i in 1:nrow(data)) {
LB <- c(LB,classes[data[i,1]])
UB <- c(UB,classes[data[i,1]+1])
}
data <- data.frame(xclass, weights, oecd, LB, UB)
data$UB[data$UB == Inf] <- upper * classes[length(classes)-1]
data$LBadj <- data$LB/data$oecd
data$UBadj <- data$UB/data$oecd
data$NIntervals <- paste0(round(data$LBadj, digits = 0), round(data$UBadj,
digits = 0))
data$Mid <- 1/2 * (data$UBadj + data$LBadj)
gridx = seq(min(data$LBadj), max(data$UBadj), length = evalpoints)
Mestimates <- density(data$Mid, from = min(gridx), to = max(gridx),
n = length(gridx), bw = 2 * max(data$UBadj)/
length(unique(data$NIntervals)))$y
resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(data$Mid))
resultW = matrix(ncol = c(burnin + samples), nrow = length(xclass))
for (j in 1:(burnin + samples)) {
new = c()
EstDat = matrix(ncol = 2, nrow = nrow(data))
newWeights = c()
for (i in 1:(length(unique(data$NIntervals)))) {
dataTemp <- data[data$NIntervals == unique(data$NIntervals)[i],]
LBTemp <- unique(dataTemp$LBadj)
UBTemp <- unique(dataTemp$UBadj)
selectionGrid <- gridx[gridx >= LBTemp & gridx < UBTemp]
newWeights <-c(newWeights, dataTemp$weights)
probs = as.vector(Mestimates[gridx%in%selectionGrid])
points = gridx[gridx%in%selectionGrid]
npoints = nrow(dataTemp)
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = "nrd0", adjust = 1)
Mestimates <- NewDensity$y
resultDensity[, j] = Mestimates
resultX[, j] = new
if(is.null(weights)){resultW <- NULL} else {
resultW[,j] = newWeights}
}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
}
est <- list(Mestimates = Mestimates, resultDensity = resultDensity,
resultX = resultX, xclass = xclass, gridx = gridx, classes = classes,
burnin = burnin, samples = samples, resultW = resultW)
return(est)
}
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary,
bw = bw, evalpoints = evalpoints, adjust = adjust,
upper = upper, weights = weights, oecd = oecd)
Indicators.run <- NULL
for (i in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
# Internal documentation -------------------------------------------------------
# The function estimates the pre-defined indicators
indicators.est <- function(x,threshold, custom_indicator, weights) {
if (is.null(weights)) {
if(is.na(threshold)) {
threshold <- 0.6*median(x)
} else {
threshold <- threshold*median(x)
}
results <- c(mean = mean(x),
gini = ineq(x),
hcr = mean(x<threshold),
quant10 = unname(quantile(x, probs = c(0.1))),
quant25 = unname(quantile(x, probs = c(0.25))),
quant50 = unname(quantile(x, probs = c(0.50))),
quant75 = unname(quantile(x, probs = c(0.75))),
quant90 = unname(quantile(x, probs = c(0.90))) ,
pgap = mean((x<threshold)*(threshold-x)/threshold),
qsr = sum(x[(x>quantile(x,0.8))])/sum(x[(x<quantile(x,0.2))])
)
if (!is.null(custom_indicator)){
c.indicator <- NULL
for(i in 1:length(custom_indicator)) {
c.indicator <- c(c.indicator, custom_indicator[[i]](x, threshold))
}
names(c.indicator) <- names(custom_indicator)
results <- c(results, c.indicator)
}
} else {
sw <- sum(weights)
thresholdW <-  threshold * weighted.quantile(x,
w = weights,
probs = .5)
results <- c(mean = weighted.mean(x, w = weights),
gini =  gini(x, weights = weights)$value/100,
hcr =  arpr(x, weights = weights, p = threshold)$value/100,
quant10 =  unname(weighted.quantile(x, w = weights, probs = 0.1)),
quant25 =  unname(weighted.quantile(x, w = weights, probs = 0.25)),
quant50 =  unname(weighted.quantile(x, w = weights, probs = 0.5)),
quant75 =  unname(weighted.quantile(x, w = weights, probs = 0.75)),
quant90 =  unname(weighted.quantile(x, w = weights, probs = 0.9)),
pgap = sum(weights * (x < thresholdW) * (thresholdW - x)
/ thresholdW) / sw,
qsr = qsr(x, weights = weights)$value)
if (!is.null(custom_indicator)){
c.indicator <- NULL
for(i in 1:length(custom_indicator)) {
c.indicator <- c(c.indicator, custom_indicator[[i]](x, threshold, weights))
}
names(c.indicator) <- names(custom_indicator)
results <- c(results, c.indicator)
}
}
return(results)
}
Indicators.run <- NULL
for (i in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
Indicators <- rowMeans(Indicators.run)
(bootstrap.se==TRUE)
results.kernel <- NULL
i<-1
Sys.sleep(0.1)
boot_samp <- xclass[sample(length(xclass), size=length(xclass), replace = TRUE)]
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust, upper = upper,
weights= weights, oecd = oecd)
Indicators.run <- NULL
if (bootstrap.se==TRUE) {
Standard.Error <- standardError.est(b = b, xclass = xclass,
classes = classes, burnin = burnin,
samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust,
threshold = threshold,
custom_indicator = custom_indicator, upper = upper,
weights = weights, oecd = oecd)
}
# Internal documentation -------------------------------------------------------
# The function estimates the standard errors of the indicators
standardError.est <- function(b, xclass, classes, burnin, samples, boundary, bw, evalpoints, adjust, threshold,
custom_indicator, upper, weights, oecd){
pb <- txtProgressBar(min = 1, max = b, style = 3)
results.kernel <- NULL
for (i in 1:b) {
Sys.sleep(0.1)
boot_samp <- xclass[sample(length(xclass), size=length(xclass), replace = TRUE)]
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust, upper = upper,
weights= weights, oecd = oecd)
Indicators.run <- NULL
for (j in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,j],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,j]))
}
results.kernel <- rbind(results.kernel,rowMeans(Indicators.run))
setTxtProgressBar(pb, i)
}
se.boot <- apply(results.kernel,2,function(x){sqrt(mean((x-mean(x))^2))})
return(se.boot)
}
if (bootstrap.se==TRUE) {
Standard.Error <- standardError.est(b = b, xclass = xclass,
classes = classes, burnin = burnin,
samples = samples, boundary = boundary, bw = bw,
evalpoints = evalpoints, adjust = adjust,
threshold = threshold,
custom_indicator = custom_indicator, upper = upper,
weights = weights, oecd = oecd)
}
results <- list(Point_estimate = Indicators, Standard_Error = Standard.Error,
Mestimates = density.est$Mestimates,
resultDensity = density.est$resultDensity,
resultX = density.est$resultX,
xclass = xclass, gridx = density.est$gridx,
classes = classes, burnin = burnin,
samples = samples, Point_estimate.run = Indicators.run,
oecd = oecd, weights = weights)
str(results)
help("kdeAlgo")
library(ICD)
example("kdeAlgo")
library(ICD)
install.packages("roxygen2")
library(ICD)
Exam
head(Exam)
load(Exa,)
load(Exam)
data <- Exa,
data <- Exam
library(ICD)
help("kdeAlgo")
data <- Exa,
data <- Exam
?weights
installed.packages("mlmRev")
install.packages("mlmRev")
install.packages("Kernelheaping")
library(ICD)
install.packages("devtools")
install.packages("roxygen2")
install.packages(c("ineq", "truncnorm",
"lme4",
"MuMIn",
"formula.tools",
"mvtnorm",
"spatstat",
"laeken",
"weights"))
.libPaths()
library(smicd)
install.packages(c("mlmRev", "Kernelheaping"))
library(Kernelheaping)
install.packages("sp")
example("semLm")
# Load and prepare data
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
# Run model with default settings
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10)
summary(model)
test <- summary(model)
length(test)
test$call
str(test$call)
language(test$call)
names(test$call)
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4)
test2 <- summary(model2)
test2$random
library(smicd)
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
# Run model with default settings
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10)
summary(model)
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4)
test2 <- summary(model2)
test2$random
summary(model)
test2 <- summary(model2)
test2
# Run model with default settings
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, trafo = "bc")
model$lambda
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "bc")
# Run model with default settings
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, trafo = "log")
model$lambda
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10)
model$lambda
names(model$call)
library(smicd)
# Run model with default settings
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, trafo = "bc")
summary(model)
# Run model with default settings
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, trafo = "log")
summary(model)
# Run model with default settings
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10)
summary(model)
library(smicd)
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "bc")
summary(model2)
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log")
summary(model2)
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4)
summary(model2)
str(model)
str(model2)
VaCovMa
model2$VaCov
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
# semLm without transformation, without bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10)
summary(model)
# semLm with log, without bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, trafo = "log")
summary(model)
# semLm with Box-Cox, without bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, trafo = "bc")
summary(model)
# semLm without transformation, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=2)
summary(model)
# semLm with log, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=2, trafo = "log")
summary(model)
# semLm with Box-Cox, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=2, trafo = "bc")
summary(model)
library(smicd)
# semLm without transformation, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=2)
summary(model)
# semLm with log, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=2, trafo = "log")
summary(model)
# semLm with Box-Cox, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=2, trafo = "bc")
summary(model)
# semlme no trafo no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4)
summary(model2)
# semlme log no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log")
summary(model2)
# semlme bc no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "bc")
summary(model2)
# semlme no trafo  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, bootstrap.se = TRUE, b = 2)
summary(model2)
# semlme log  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log", bootstrap.se = TRUE, b = 2)
summary(model2)
# semlme bc  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "bc", bootstrap.se = TRUE, b = 2)
summary(model2)
# semlme no trafo no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4)
summary(model2)
# semlme log no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log")
summary(model2)
# semlme bc no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "bc")
library(smicd)
# semlme no trafo no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4)
summary(model2)
# semlme log no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log")
summary(model2)
# semlme bc no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "bc")
summary(model2)
# semlme no trafo  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, bootstrap.se = TRUE, b = 2)
summary(model2)
# semlme log  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log", bootstrap.se = TRUE, b = 2)
summary(model2)
# semlme bc  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "bc", bootstrap.se = TRUE, b = 2)
summary(model2)
# semlme no trafo no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4)
summary(model2)
# semlme log no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log")
summary(model2)
# semlme bc no boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "bc")
summary(model2)
# semlme no trafo  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, bootstrap.se = TRUE, b = 2)
summary(model2)
# semlme log  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log", bootstrap.se = TRUE, b = 2)
summary(model2)
# semlme bc  boot,
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "bc", bootstrap.se = TRUE, b = 2)
summary(model2)
# semlme log  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log", bootstrap.se = TRUE, b = 50)
summary(model2)
plot(model2)
# semlme log  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 20, samples = 40, trafo = "log", bootstrap.se = TRUE, b = 50)
summary(model2)
plot(model2)
# semlme log  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 20, samples = 40, bootstrap.se = TRUE, b = 50)
# semlme log  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 20, samples = 40, bootstrap.se = TRUE, b = 50)
# semlme log  boot, only random int
model2 <- semLm(formula = examsc.class ~ standLRT + schavg, data = data, classes = classes, burnin = 20, samples = 40, bootstrap.se = TRUE, b = 50)
summary(model2)
model2
model2 <- semLm(formula = examsc.class ~ standLRT + schavg, data = data, classes = classes, burnin = 20, samples = 40, bootstrap.se = TRUE, b = 50)
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
# semLm with log, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=50, trafo = "log")
summary(model)
summary(model)
plot(model)
library(smicd)
# Load and prepare data
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
# semLm without transformation, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=40)
summary(model)
# semLm with log, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=50, trafo = "log")
summary(model)
# semLm with Box-Cox, with bootstrap
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, burnin = 4, samples = 10, bootstrap.se = TRUE,
b=50, trafo = "bc")
summary(model)
# semlme no trafo  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, bootstrap.se = TRUE, b = 40)
summary(model2)
# semlme log  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log", bootstrap.se = TRUE, b = 40)
summary(model2)
# semlme no trafo  boot, only random int
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 4, samples = 4, bootstrap.se = TRUE, b = 50)
summary(model2)
library(smicd)
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(1|school), data = data, classes = classes, burnin = 4, samples = 4, trafo = "log", bootstrap.se = TRUE, b = 40)
summary(model2)
