if (!is.null(x$conv.lambda)){
par(mfrow=c(2,1))
plot(x$conv.lambda, main =  expression(paste("Convergence ",lambda)),
xlab = "Iteration Step",
ylab = "Point estimate for each iteration")
abline(v=x$b.lambda)
means <- NULL
for (j in 1:x$samples){
means <- c(means, mean(x$conv.lambda[x$burnin:j]))
}
point = c(rep(means[1]-.Machine$double.xmin, x$burnin),means)
plot(point,xlim = c(0, (x$burnin + x$samples)),
col = ifelse(point==means[1]-.Machine$double.xmin,'white','black'),
xlab = "Iteration step", ylab = "Average up to iterstion step M")
abline(h=x$lambda)
abline(v=x$burnin)
cat("Press [enter] to continue")
line <- readline()
}
?par
library(smicd)
?Sys.setenv
Sys.setenv
Sys.setenv()
Sys.setenv(R_GSCMD = "C:\\Program Files\\gs\\gs9.52\\bin\\gswin62c.exe")
Sys.getenv("R_GSCMD")
Sys.setenv(R_GSCMD = "C:\\Program Files\\gs\\gs9.19\\bin\\gswin64c.exe")
Sys.getenv("R_GSCMD")
Sys.setenv(R_GSCMD = "C:\\Program Files\\gs\\gs9.52\\bin\\gswin64c.exe")
version
library(smicd)
library(smicd)
help("kdeAlgo")
x=rlnorm(500, meanlog = 8, sdlog = 1)
classes <- c(0,500,1000,1500,2000,2500,3000,4000,5000, 6000,8000,10000, 15000,Inf)
xclass <- cut(x,breaks=classes)
weights <- abs(rnorm(500,0,1))
oecd <- rep(seq(1,6.9,0.3),25)
Indicator <- kdeAlgo(xclass = xclass, classes = classes)
plot(Indicator)
Indicator_custom <- kdeAlgo(xclass = xclass, classes = classes,
custom_indicator = list(quant5 = function(y, threshold)
{quantile(y, probs = 0.05)}))
plot(Indicator_custom)
Indicator_weights <- kdeAlgo(xclass = xclass, classes = classes,
weights = weights, oecd = oecd)
plot(Indicator_custom)
## End(Not run)
help("semLm")
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
# Run model with default settings
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes)
summary(model)
plot(model)
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, trafo = "bc")
summary(model)
plot(model)
model <- semLm(formula = examsc.class ~ standLRT + schavg, data = data,
classes = classes, trafo = "bc", burnin = 10, samples = 10)
summary(model)
plot(model)
help("semLme")
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
# Run model with random intercept and default settings
model1 <- semLme(formula = examsc.class ~ standLRT + schavg + (1|school),
data = data, classes = classes)
summary(model1)
print(model1)
plot(model1)
model1 <- semLme(formula = examsc.class ~ standLRT + schavg + (1|school),
data = data, classes = classes, burnin = 10, samples = 10,
trafo = "bc")
summary(model1)
plot(model1)
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes)
summary(model2)
plot(model2)
model2 <- semLme(formula = examsc.class ~ standLRT + schavg +
(standLRT|school), data = data, classes = classes, burnin = 10, samples = 10,
trafo = "bc")
summary(model2)
plot(model2)
devtools::release()
285/100*9*1.07
285/100*9*1.09
toBibtex(citation("actuar",auto=TRUE))
?citation()
installed.packages("actuar")
install.packages("actuar")
library("actuar")
toBibtex(citation("actuar",auto=TRUE))
toBibtex(citation("actuar"))
toBibtex(citation("fitdistrplus",auto=TRUE))
install.packages("fitdistrplus")
toBibtex(citation("fitdistrplus",auto=TRUE))
toBibtex(citation("fitdistrplus"))
toBibtex(citation("smicd",auto=TRUE))
toBibtex(citation("stats",auto=TRUE))
toBibtex(citation("stats"))
toBibtex(citation("MASS",auto=TRUE))
toBibtex(citation("MASS"))
toBibtex(citation("IntReg",auto=TRUE))
install.packages("IntReg")
library(IntReg)
install.packages("IntReg")
install.packages("survival")
library(survival)
ltoBibtex(citation("survival",auto=TRUE))
toBibtex(citation("survival",auto=TRUE))
toBibtex(citation("survival"))
install.packages("lme4")
toBibtex(citation("lme4",auto=TRUE))
toBibtex(citation("lme4"))
install.packages("nlme")
toBibtex(citation("nlme",auto=TRUE))
toBibtex(citation("nlme"))
install.packages("ordinal")
toBibtex(citation("ordinal",auto=TRUE))
toBibtex(citation("ordinal"))
install.packages("ineq")
install.packages("truncnorm")
install.packages("MuMIn")
install.packages("formula.tools")
install.packages("mvtnorm")
install.packages("spatstat")
install.packages("laeken")
install.packages("weights")
help(smiced)
help(smicd)
library(smicd)
help(smicd)
help("kdeAlgo")
dataH <- read_csv("C:/Users/Paul/Desktop/R Journal/data/DE_puf_h_silc2013.csv")
dataH <- read.csv("C:/Users/Paul/Desktop/R Journal/data/DE_puf_h_silc2013.csv")
head(dataH)
dataD <- read_csv("C:/Users/Paul/Desktop/R Journal/data/DE_puf_d_silc2013.csv")
dataD <- read.csv("C:/Users/Paul/Desktop/R Journal/data/DE_puf_d_silc2013.csv")
dataH$ID <- dataH$HB030
dataD$ID <- dataD$DB030
data <- merge(dataH, dataD, by = "ID" )
hhincome_net <- data$HY020                     # Total disposable HH income
hhweight <- data$DB090
data <- data.frame(hhincome_net, hhweight)
data <- data[hhincome_net>0,]
data$hhincome_net <- data$hhincome_net/12
summary(data$hhincome_net)
classes <- c(0,150,300,500,700,900,1100,1300,1500,1700,2000,2300,2600,2900,
3200,3600,4000,4500,5000,5500,6000,7500,10000,18000,Inf)
data$c.hhincome <- cut(data$hhincome_net, breaks = classes)
table(data$c.hhincome)
Indicators <- kdeAlgo(xclass = data$c.hhincome, classes = classes,
bootstrap.se = TRUE, custom_indicator =
list(quant05 = function(y, treshold, weights){wtd.quantile(y, probs = 0.05, weights)},
quant95 = function(y, treshold, weights){wtd.quantile(y, probs = 0.95, weights)}),
weights = data$hhweight
)
library(laeken)
Indicators <- kdeAlgo(xclass = data$c.hhincome, classes = classes,
bootstrap.se = TRUE, custom_indicator =
list(quant05 = function(y, treshold, weights){wtd.quantile(y, probs = 0.05, weights)},
quant95 = function(y, treshold, weights){wtd.quantile(y, probs = 0.95, weights)}),
weights = data$hhweight
)
library(laeken)
?wtd.quantile
library(Hmisc)
?wtd.quantile
Indicators <- kdeAlgo(xclass = data$c.hhincome, classes = classes,
bootstrap.se = TRUE, custom_indicator =
list(quant05 = function(y, treshold, weights){wtd.quantile(y, probs = 0.05, weights)},
quant95 = function(y, treshold, weights){wtd.quantile(y, probs = 0.95, weights)}),
weights = data$hhweight
)
data(eusilc)
data(eusilc)
hhincome_net <- eusilc$eqIncome
hhweight <- eusilc$db090
summary(hhweight)
summary(hhincome_net)
hhincome_net <- eusilc$eqIncome[eusilc$eqIncome>0]
summary(hhincome_net)
data(eusilc)
eusilc <- eusilc[eqIncome>0,]
data(eusilc)
eusilc <- eusilc[eusilc$eqIncome>0,]
hhincome_net <- eusilc$eqIncome/12
hhweight <- eusilc$db090
summary(hhincome_net)
classes <- c(0,150,300,500,700,900,1100,1300,1500,1700,2000,2300,2600,2900,
3200,3600,4000,4500,5000,5500,6000,7500,10000,Inf)
data(eusilc)
eusilc <- eusilc[eusilc$eqIncome>0,]
eusilc$hhincome_net <- eusilc$eqIncome/12
eusilc$hhweight <- eusilc$db090
summary(hhincome_net)
classes <- c(0,150,300,500,700,900,1100,1300,1500,1700,2000,2300,2600,2900,
3200,3600,4000,4500,5000,5500,6000,7500,10000,Inf)
eusilc$c.hhincome <- cut(eusilc$hhincome_net, breaks = classes)
table(eusilc$c.hhincome)
classes <- c(0,150,300,500,700,900,1100,1300,1500,1700,2000,2300,2600,2900,
3200,3600,4000,4500,5000,5500,6000,7500,Inf)
eusilc$c.hhincome <- cut(eusilc$hhincome_net, breaks = classes)
table(eusilc$c.hhincome)
Indicators <- kdeAlgo(xclass = data$c.hhincome, classes = classes, burnin = 5, samples = 10, bootstrap.se = 10,
bootstrap.se = TRUE, custom_indicator =
list(quant05 = function(y, treshold, weights){wtd.quantile(y, probs = 0.05, weights)},
quant95 = function(y, treshold, weights){wtd.quantile(y, probs = 0.95, weights)}),
weights = data$hhweight
)
Indicators <- kdeAlgo(xclass = data$c.hhincome, classes = classes, burnin = 5, samples = 10, b = 10,
bootstrap.se = TRUE, custom_indicator =
list(quant05 = function(y, treshold, weights){wtd.quantile(y, probs = 0.05, weights)},
quant95 = function(y, treshold, weights){wtd.quantile(y, probs = 0.95, weights)}),
weights = data$hhweight
)
Indicators <- kdeAlgo(xclass = eusilc$c.hhincome, classes = classes, burnin = 5, samples = 10, b = 10,
bootstrap.se = TRUE, custom_indicator =
list(quant05 = function(y, treshold, weights){wtd.quantile(y, probs = 0.05, weights)},
quant95 = function(y, treshold, weights){wtd.quantile(y, probs = 0.95, weights)}),
weights = eusilc$hhweight
)
print(Indicators)
plot(Indicators)
Indicators <- kdeAlgo(xclass = eusilc$c.hhincome, classes = classes, burnin = 20, samples = 100, b = 10,
bootstrap.se = TRUE, custom_indicator =
list(quant05 = function(y, treshold, weights){wtd.quantile(y, probs = 0.05, weights)},
quant95 = function(y, treshold, weights){wtd.quantile(y, probs = 0.95, weights)}),
weights = eusilc$hhweight
)
print(Indicators)
print(Indicators)
plot(Indicators)
#
# The R Package smicd: Statistical Methods for Interval-Censored Data
#
# Packages
library(smicd)
library(Hmisc)
################################################################################
#
# Direct estimation via the KDE algorithm
#
################################################################################
set.seed(123)
#
# Load and prepare EU Silc data
#
data(eusilc)
eusilc <- eusilc[eusilc$eqIncome>0,]
eusilc$hhincome_net <- eusilc$eqIncome/12
eusilc$hhweight <- eusilc$db090
summary(hhincome_net)
classes <- c(0,150,300,500,700,900,1100,1300,1500,1700,2000,2300,2600,2900,
3200,3600,4000,4500,5000,5500,6000,7500,Inf)
eusilc$c.hhincome <- cut(eusilc$hhincome_net, breaks = classes)
table(eusilc$c.hhincome)
#
# Run KDE algorithm (decrease default number of burnins and/or samples for
# (decrease default number of burnins and/or samples for faster estimation time)
#
Indicators <- kdeAlgo(xclass = eusilc$c.hhincome, classes = classes,
bootstrap.se = TRUE, custom_indicator =
list(quant05 = function(y, treshold, weights){wtd.quantile(y, probs = 0.05, weights)},
quant95 = function(y, treshold, weights){wtd.quantile(y, probs = 0.95, weights)}),
weights = eusilc$hhweight
)
save.image("C:/Users/Paul/Desktop/R Journal/kde_example.RData")
print(Indicators)
plot(Indicators)
toBibtex(citation("laeken",auto=TRUE))
toBibtex(citation("laeken"))
table(c.hhincome)
data(eusilc)
eusilc <- eusilc[eusilc$eqIncome>0,]
hhincome_net <- eusilc$eqIncome/12
hhweight <- eusilc$db090
classes <- c(0,150,300,500,700,900,1100,1300,1500,1700,2000,2300,2600,2900,
3200,3600,4000,4500,5000,5500,6000,7500,Inf)
c.hhincome <- cut(hhincome_net, breaks = classes)
table(c.hhincome)
library(smicd)
library(Hmisc)
################################################################################
#
# Direct estimation
#
################################################################################
set.seed(123)
#
# Load and prepare EU SILC data
#
data(eusilc)
eusilc <- eusilc[eusilc$eqIncome>0,]
hhincome_net <- eusilc$eqIncome/12
hhweight <- eusilc$db090
intervals <- c(0,150,300,500,700,900,1100,1300,1500,1700,2000,2300,2600,2900,
3200,3600,4000,4500,5000,5500,6000,7500,Inf)
c.hhincome <- cut(hhincome_net, breaks = intervals)
table(c.hhincome)
#
# Run KDE algorithm (decrease default number of burn-ins and/or samples for
# (decrease default number of burn-ins and/or samples for faster estimation time)
#
Indicators <- kdeAlgo(xclass = c.hhincome, classes = intervals,
bootstrap.se = TRUE, custom_indicator =
list(quant05 = function(y, treshold, weights){wtd.quantile(y, probs = 0.05, weights)},
quant95 = function(y, treshold, weights){wtd.quantile(y, probs = 0.95, weights)}),
weights = hhweight
)
library(smicd)
library(smicd)
data(Exam)
intervals <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
Exam$examsc.class<- cut(Exam$examsc, intervals)
table(Exam$examsc.class)
LM <- semLm(formula = examsc.class ~ standLRT + sex, data = Exam,
classes = interval,  bootstrap.se = TRUE, b=5)
LM <- semLm(formula = examsc.class ~ standLRT + sex, data = Exam,
classes = intervals,  bootstrap.se = TRUE, b=5)
plot(LM)
modelInt <- sem.lme(formula = examsc.class ~ standLRT + sex + (1|school),
data = data, classes = classes, burnin = 10,
samples = 40, trafo = "None", adjust = 2,
bootstrap.se = TRUE, b=5)
modelInt <- semLME(formula = examsc.class ~ standLRT + sex + (1|school),
data = data, classes = classes, burnin = 10,
samples = 40, trafo = "None", adjust = 2,
bootstrap.se = TRUE, b=5)
?semLME
?semLM
LM <- semLm(formula = examsc.class ~ standLRT + sex, data = Exam,
classes = intervals,  bootstrap.se = TRUE, b=5)
modelInt <- semLME(formula = examsc.class ~ standLRT + sex + (1|school),
data = data, classes = classes, burnin = 10,
samples = 40, trafo = "None", adjust = 2,
bootstrap.se = TRUE, b=5)
library(smicd)
modelInt <- semLME(formula = examsc.class ~ standLRT + sex + (1|school),
data = data, classes = classes, burnin = 10,
samples = 40, trafo = "None", adjust = 2,
bootstrap.se = TRUE, b=5)
modelInt <- semLme(formula = examsc.class ~ standLRT + sex + (1|school),
data = data, classes = classes, burnin = 10,
samples = 40, trafo = "None", adjust = 2,
bootstrap.se = TRUE, b=5)
modelInt <- semLme(formula = examsc.class ~ standLRT + sex + (1|school),
data = Exam, classes = intervals, burnin = 10,
samples = 40, trafo = "None", adjust = 2,
bootstrap.se = TRUE, b=5)
summary(modelInt)
LME <- semLme(formula = examsc.class ~ standLRT + sex + (standLRT|school),
data = data, classes = classes, bootstrap.se = TRUE, b=5)
LME <- semLme(formula = examsc.class ~ standLRT + sex + (standLRT|school),
data = Exam, classes = intervals, bootstrap.se = TRUE, b=5)
summary(LME)
plot(LME)
styler:::style_active_file()
styler:::style_active_file()
library(smicd)
################################################################################
#
# Linear (mixed) regression
#
################################################################################
set.seed(123)
#
# Load and prepare London school data
#
data(Exam)
intervals <- c(1, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.7, 8.5, Inf)
Exam$examsc.class <- cut(Exam$examsc, intervals)
table(Exam$examsc.class)
LM <- semLm(
formula = examsc.class ~ standLRT + sex, data = Exam,
classes = intervals, bootstrap.se = TRUE
)
table(Exam$examsc.class)
summary(LM)
plot(LM)
LME <- semLme(
formula = examsc.class ~ standLRT + sex + (standLRT | school),
data = Exam, classes = intervals, bootstrap.se = TRUE
)
summary(LME)
plot(LME)
install.packages("mlmRev")
library(mlmRev)
toBibtex(citation("mlmRev",auto=TRUE));
toBibtex(citation("mlmRev"));
library(smicd)
library(smicd)
set.seed(123)
data(eusilc)
eusilc <- eusilc[eusilc$eqIncome > 0, ]
hhincome_net <- eusilc$eqIncome / 12
hhweight <- eusilc$db090
intervals <- c(
0, 150, 300, 500, 700, 900, 1100, 1300, 1500, 1700, 2000, 2300, 2600, 2900,
3200, 3600, 4000, 4500, 5000, 5500, 6000, 7500, Inf
)
c.hhincome <- cut(hhincome_net, breaks = intervals)
table(c.hhincome)
?wtd.quantile
library(laeken)
library(smicd)
library(Hmisc)
library(laeken)
################################################################################
#
# Direct estimation
#
################################################################################
set.seed(123)
#
# Load and prepare EU SILC data
#
data(eusilc)
eusilc <- eusilc[eusilc$eqIncome > 0, ]
hhincome_net <- eusilc$eqIncome / 12
hhweight <- eusilc$db090
intervals <- c(
0, 150, 300, 500, 700, 900, 1100, 1300, 1500, 1700, 2000, 2300, 2600, 2900,
3200, 3600, 4000, 4500, 5000, 5500, 6000, 7500, Inf
)
c.hhincome <- cut(hhincome_net, breaks = intervals)
table(c.hhincome)
Indicators <- kdeAlgo(
xclass = c.hhincome, classes = intervals,
bootstrap.se = FALSE, custom_indicator =
list(
quant05 = function(y, treshold, weights) {
wtd.quantile(y, probs = 0.05, weights)
},
quant95 = function(y, treshold, weights) {
wtd.quantile(y, probs = 0.95, weights)
}
),
weights = hhweight
)
print(Indicators)
install.packages("roxygen2")
install.packages("R.rsp")
library(spatstat)
?weighted.quantile
?wtd.quantile
install.packages("rmarkdown")
devtools::document()
install.packages("devtools")
devtools::document()
?wtd.quantile
devtools::document()
?wtd.quantile
install.packages("qpdf")
install.packages("Kernelheaping")
styler:::style_active_file()
styler:::style_active_file()
styler:::style_selection()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
help(smicd)
help(smicd)
detach("package:smicd", unload = TRUE)
remove.packages("smicd", lib="~/R/win-library/4.0")
help(smicd)
library(smicd)
help(smicd)
detach("package:smicd", unload = TRUE)
library(smicd)
?smicd
remove.packages("smicd", lib="~/R/win-library/4.0")
library(smicd)
?smicd
remove.packages("smicd", lib="~/R/win-library/4.0")
install.packages("~/GitHub/smicd_1.1.1.tar.gz", repos = NULL, type = "source")
library(smicd)
?smicd
install.packages("~/GitHub/smicd_1.1.1.tar.gz", repos = NULL, type = "source")
library(smicd)
install.packages("~/GitHub/smicd_1.1.1.tar.gz", repos = NULL, type = "source")
library(smicd)
help(smicd)
help("kdeAlgo")
styler:::style_selection()
styler:::style_active_file()
styler:::style_active_file()
help("kdeAlgoObject")
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_selection()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
help("plot.kdeAlgo")
styler:::style_active_file()
help("plot.sem")
styler:::style_active_file()
help("print.kdeAlgo")
styler:::style_active_file()
help("print.sem")
styler:::style_active_file()
