parameter[[i]] <- apply(parameter[[i]][,-c(1:burnin)],1,mean)
}
}
return(parameter)
}
names(parameter.final$coef) <- rownames(summary(regclass)$coefficients)
parameter.final <- parameters.est(parameter = parameter, burnin = burnin)
names(parameter.final$coef) <- rownames(summary(regclass)$coefficients)
formula = o.formula
data = o.data
classes = o.classes
burnin = burnin
samples = samples
trafo = trafo
adjust = adjust
b = b
coef = parameter.final$coef
sigmae = parameter.final$sigmae
VaCov = parameter.final.ma$VaCov
nameRI = names(ranef(regclass))
nameRS = names(ranef(regclass)[[1]])[2]
regmodell = regclass
lambda
lambda = m.lambda
lambda
save.image("C:/Users/paulwalter/Desktop/std.error.RData")
boot_data <- data
fixedformula <- as.formula(lme4::nobars(formula(regmodell))[-2])
fixedeffect <- model.matrix(fixedformula,data = boot_data)
mu <- as.matrix(fixedeffect) %*% coef
name.fe <- names(coef)
name.RI <- nameRI
name.RS <- nameRS
formula
names(formula)
fixedformula
fixedeffect
name.dep <- all.vars(formula)[1]
name.dep
coef <- NULL
for (i in 1:b){
p.ranef <- NULL
for (j in 1 :length(unique(boot_data[,tail(all.vars(formula), n=1)]))){
p.ranef <- rbind(p.ranef, apply(rmvnorm(n = 1, mean = rep(0, nrow(VaCov))
,sigma = VaCov), 2,
function(x) {rep(x,table(boot_data[,tail(all.vars(formula), n=1)])[j])}))
}
i<-1
p.ranef <- NULL
for (j in 1 :length(unique(boot_data[,tail(all.vars(formula), n=1)]))){
p.ranef <- rbind(p.ranef, apply(rmvnorm(n = 1, mean = rep(0, nrow(VaCov))
,sigma = VaCov), 2,
function(x) {rep(x,table(boot_data[,tail(all.vars(formula), n=1)])[j])}))
}
??rmvnorm
library(mvtnorm)
for (j in 1 :length(unique(boot_data[,tail(all.vars(formula), n=1)]))){
p.ranef <- rbind(p.ranef, apply(rmvnorm(n = 1, mean = rep(0, nrow(VaCov))
,sigma = VaCov), 2,
function(x) {rep(x,table(boot_data[,tail(all.vars(formula), n=1)])[j])}))
}
if(is.na(nameRS)) {boot_data$ynew <- mu + p.ranef[,1] + rnorm(nrow(boot_data), 0 , sigmae)}
if(!is.na(nameRS)) {boot_data$ynew <- mu + p.ranef[,1] + p.ranef[,2]*boot_data[,name.RS]+
rnorm(nrow(boot_data), 0 , sigmae)}
head(data)
head(boot_data)
classes
plot(boot_data$ynew)
hist(boot_data$ynew)
boot_data$ynew[boot_data$ynew<classes[1]] <- classes[1]+.Machine$double.eps
boot_data$ynew[boot_data$ynew>classes[length(classes)]] <-
classes[length(classes)]+.Machine$double.eps
hist(boot_data$ynew)
classes
(trafo="log")
if (trafo="log"){boot_data$ynew <- exp(boot_data$ynew)}
if (trafo="log"){boot_data$ynew <- exp(boot_data$ynew)}
if (trafo=="log"){boot_data$ynew <- exp(boot_data$ynew)}
hist(boot_data$ynew)
classes
boot_data
paste0("boot_data$",name.dep)
assign(paste0("boot_data$",name.dep), cut(boot_data$ynew, classes))
head(boot_data)
classes
library(smicd)
# Run model with random intercept and default settings
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
model1 <- semLme(formula = examsc.class ~ standLRT + schavg + (1|school),
data = data, classes = classes, burnin = 2, samples = 4, bootstrap.se = TRUE, b = 50)
library(smicd)
# Run model with random intercept and default settings
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
model1 <- semLme(formula = examsc.class ~ standLRT + schavg + (1|school),
data = data, classes = classes, burnin = 2, samples = 4, bootstrap.se = TRUE, b = 50, trafo = "log")
summary(model1)
help("semLme")
model1 <- semLme(formula = examsc.class ~ standLRT + schavg + (standLRT|school),
data = data, classes = classes, burnin = 2, samples = 4, bootstrap.se = TRUE, b = 50, trafo = "log")
summary(model1)
model1 <- semLme(formula = examsc.class ~ standLRT + schavg + (1|school),
data = data, classes = classes, burnin = 2, samples = 4, bootstrap.se = TRUE, b = 50, trafo = "bc")
load("C:/Users/paulwalter/Desktop/std.error.RData")
load("C:/Users/paulwalter/Desktop/semLME.RData")
trafo = "bc"
# Internal documentation -------------------------------------------------------
# The function estimates the final parameters
parameters.est <- function(parameter, burnin) {
for (i in 1:length(parameter)) {
if (is.null(dim(parameter[[i]]))) {
parameter[[i]] <- mean(parameter[[i]][-c(1:burnin)])
} else {
parameter[[i]] <- apply(parameter[[i]][,-c(1:burnin)],1,mean)
}
}
return(parameter)
}
# Internal documentation -------------------------------------------------------
# The function estimates the final parameters from matrices
parameters.est.ma <- function(parameter, burnin) {
for (i in 1:length(parameter)) {
parameter.tmp <- array(unlist(parameter[[i]]), dim = c(nrow(parameter[[i]][[1]]),
ncol(parameter[[i]][[1]]),
length(parameter[[i]])))
parameter[[i]] <- apply(parameter.tmp, c(1,2), function(x){mean(x[-c(1:burnin)])})}
return(parameter)
}
# Internal documentation -------------------------------------------------------
#
# ICC
icc.est <- function(model){
u <- as.data.frame(VarCorr(model))$sdcor[1]
e <- sigma(model)
icc <- u / (u + e)
return(icc)
}
# Internal documentation -------------------------------------------------------
# The function estimates the interval midpoints
midpoints.est <- function(formula, data, classes) {
model_frame <- model.frame(formula, data = data)
yclass <- model.response(model_frame)
yclassl <- model.response(model_frame)
levels(yclassl) <- 1:length(levels(yclassl))
yclassl <- as.numeric(as.vector(yclassl))
data$yclassl <- yclassl
intervals <- vector("list", length(classes) -  1)
for (i in seq(length = length(classes) - 1)) {
intervals[[i]] <- c(classes[i], classes[i +1])
}
means <- sapply(intervals, mean)
widths <- sapply(intervals, function(x) x[2] - x[1])
meanWidth <- mean(widths[!is.infinite(widths)])
negInf <- is.infinite(means) & means < 0
if (any(negInf)) {
means[negInf] <- sapply(intervals[negInf], function(x) (x[2] +  (x[2]-
meanWidth))/2)
}
posInf <- is.infinite(means) & means > 0
if (any(posInf)) {
means[posInf] <- sapply(intervals[posInf], function(x) (x[1]+(x[1] +
meanWidth))/2)
}
yclassmeans<-means
levels(yclass) <- yclassmeans
data$pseudoy <- as.numeric(as.vector(yclass))
return(data)
}
# Internal documentation -------------------------------------------------------
#
# Estimate Lambda LME
lambda.lme.est <- function(formula, data, classes, burnin, samples, adjust) {
data <- midpoints.est(formula = formula, data = data, classes = classes)
#formula.bc <- formula
formula.bc <- as.formula(gsub(".*~","pseudoy~",formula))
#transform data and obtain lambda
BoxCox <- boxcox.lme.est(dat = data, inverse=FALSE, formula = formula.bc)
BoxCox_lambda <- BoxCox[[3]]
data$pseudoy <- BoxCox[[1]]
# transform classes
BoxCoxClasses <- boxcox.lme.est(dat=classes,lambda = BoxCox_lambda, inverse=FALSE)
classesBox <- BoxCoxClasses[[1]]
regclass <- lmer(formula.bc,data=data )
it_lambda <- (burnin+samples)*adjust
result_lambda <- vector(mode = "numeric", length = it_lambda)
pb <- txtProgressBar(min = 1, max = it_lambda, style = 3)
print("Box-Cox is slow, sry :/")
for (j in 1:(it_lambda)) {
Sys.sleep(0.1)
data$predict <- predict(regclass,data)
sigmahat <- sigma(regclass)
for (i in 1:(length(classesBox) - 1)) {
if (nrow(data[data$yclassl==i,])!=0) {
mean <- data$predict[data$yclassl==i]
pseudoy <- rtruncnorm(length(mean), a=classesBox[i], b=classesBox[i+1], mean=mean, sd=sigmahat )
data$pseudoy[data$yclassl==i] <- pseudoy
}
}
result_lambda[j] <- BoxCox_lambda
# Transform the data back
rueck <- boxcox.lme.est(dat=data, lambda = BoxCox_lambda, inverse = T)
data$pseudoy <- rueck[[1]]
# Transform data and obtain lambda
BoxCox <- boxcox.lme.est(dat=data, inverse=FALSE, formula = formula.bc)
BoxCox_y <- BoxCox[[1]]
BoxCox_lambda <- BoxCox[[3]]
data$pseudoy <- BoxCox_y
# Transform classes with nex lambda
BoxCoxClasses <- boxcox.lme.est(dat=classes,lambda = BoxCox_lambda,  inverse=FALSE)
classesBox <- BoxCoxClasses[[1]]
classesM <- BoxCoxClasses[[2]]
regclass=lmer(formula.bc,data=data )
setTxtProgressBar(pb, j)
}
lambda <- mean(result_lambda[-c(1:(burnin*adjust))])
est <- list(lambda = lambda, it.lambda = result_lambda, b.lambda = burnin*adjust,
m.lambda = samples*adjust)
return(est)
}
call <- match.call()
o.classes = classes
o.data = data
o.formula = formula
lambda <- result_lambda <- b.lambda <- m.lambda <- se <- ci <- NULL
if (trafo=="log"){classes <- log.est(y = classes)}
if (trafo=="bc") {suppressWarnings(lambda.est <-
lambda.lme.est(formula = formula,
data = data,
classes = classes,
burnin = burnin,
samples = samples,
adjust = adjust))
lambda <- lambda.est$lambda
result_lambda <- lambda.est$it.lambda
b.lambda <- lambda.est$b.lambda
m.lambda <- lambda.est$m.lambda
BoxCoxClasses <- boxcox.lme.est(dat=classes,lambda = lambda,  inverse=FALSE)
classes <- BoxCoxClasses[[1]]
}
# Internal documentation -------------------------------------------------------
#
# Box-Cox transformation for mixed linear regression
boxcox.lme.est <- function(dat, lambda=NULL, m=NULL, inverse, formula){
lambda_new <- NULL
geometric.mean<-function (x) #for RMLE in the parameter estimation
{
exp(mean(log(x)))
}
#Transformation Box-Cox
Box = function(l, y, inv=FALSE, m=NULL) #Box-Cox transformation (lambda=l)
{
if(!inv)
{
if(is.null(m))
{
m = 0
}
if((s=min(y))<=0) #with shift(=m) parameter for making data positive (>0)
{
s = abs(s)+1
}
else
{
s=0
}
m=m+s
if(abs(l)<=1e-12) #case lambda=0
{
y = log(y+m)
}
else
{
y = ((y+m)^l-1)/l
}
}
else
{
if(is.null(m)) #inverse transformation
{
m = 0
}
if(abs(l)<=1e-12) #case lambda=0
{
y = exp(y) - m
}
else
{
y = (l*y+1)^(1/l)-m
}
}
return(list(y = y, m = m)) #return of transformed data and shift (overwriten y)
}
sd_box = function(y, l, m)
{
if((m=min(y))<=0)
{
y=y-m
y=y+1
}
gm=geometric.mean(y)
if(abs(l)>1e-12)
{
y=(y^l-1)/(l*((gm)^(l-1)))
}
else
{
y=gm*log(y)
}
return(y)
}
# Estimation REML
opt_reml_box <- function(l,y,dat,m)
{
dat$pseudoy = sd_box(y=y, l = l, m=m)
mod <- lmer(formula, REML=TRUE,data = dat)
if(logLik(mod)>0)
{
return(99999)
}
return(-logLik(mod))
}
if (is.data.frame(dat)==TRUE) {
if (inverse==FALSE){
l_box <- optimise(f = opt_reml_box, interval = c(-1,2),
y= dat$pseudoy,dat = dat, m = NULL)$minimum
trans_dat <- Box(l_box, y = dat$pseudoy, inv=FALSE)$y
m <- Box(l_box, y = dat$pseudoy, inv=FALSE)$m
lambda_new <- l_box
}
if (inverse==TRUE){
trans_dat <- Box(lambda, y=dat$pseudoy , inv = TRUE, m=m)$y
}
}
if (is.data.frame(dat)==FALSE) {
if (inverse==FALSE){
trans_dat <- Box(lambda, y = dat, inv=FALSE)$y
m <- Box(lambda, y = dat, inv=FALSE)$m
}
if (inverse==TRUE){
trans_dat <- Box(lambda, y=dat , inv = TRUE, m=m)$y
}
}
res <- list(trans_dat, m, lambda_new)
return(res)
}
lambda <- lambda.est$lambda
if (trafo=="bc") {suppressWarnings(lambda.est <-
lambda.lme.est(formula = formula,
data = data,
classes = classes,
burnin = burnin,
samples = samples,
adjust = adjust))
lambda <- lambda.est$lambda
result_lambda <- lambda.est$it.lambda
b.lambda <- lambda.est$b.lambda
m.lambda <- lambda.est$m.lambda
BoxCoxClasses <- boxcox.lme.est(dat=classes,lambda = lambda,  inverse=FALSE)
classes <- BoxCoxClasses[[1]]
}
data <- midpoints.est(formula = formula, data = data, classes = classes)
formula <- as.formula(gsub(".*~","pseudoy~",formula))
regclass <- lmer(formula,data=data)
resulty <- matrix(ncol = c(burnin + samples), nrow = nrow(data))
resultcoef <- matrix(ncol = c(burnin + samples), nrow = length(regclass@beta))
result_ranef <- vector("list", burnin + samples)
result_sigmae<-vector(mode = "numeric", length = burnin+samples)
result_r2c<-vector(mode = "numeric", length = burnin+samples)
result_r2m<-vector(mode = "numeric", length = burnin+samples)
result_icc <- vector(mode = "numeric", length = burnin+samples)
VaCovMa <- vector("list", burnin+samples)
for (j in 1:(burnin + samples)) {
data$predict <- predict(regclass,data)
sigmahat <- sigma(regclass)
for (i in 1:(length(classes) - 1)) {
if (nrow(data[data$yclassl==i,])!=0) {
mean <- data$predict[data$yclassl==i]
pseudoy <- rtruncnorm(length(mean), a=classes[i], b=classes[i+1], mean=mean, sd=sigmahat )
data$pseudoy[data$yclassl==i] <- pseudoy
}
}
regclass=lmer(formula,data=data )
resultcoef[,j] <- regclass@beta
result_ranef[[j]] <- as.matrix(ranef(regclass)[[1]])
result_sigmae[j]<- sigmahat
#result_sigmau[j]<-as.data.frame(VarCorr(regclass))$sdcor[1]
result_r2m[j] <- unname(r.squaredGLMM(regclass)[1])
result_r2c[j] <- unname(r.squaredGLMM(regclass)[2])
result_icc[j] <- icc.est(model = regclass)
resulty[,j] <- data$pseudoy
VaCovMa[[j]] <- as.matrix(unclass(VarCorr(regclass))[[1]][1:ncol(ranef(regclass)[[1]]),])
}
parameter.ma <- list(ranef = result_ranef, VaCov = VaCovMa)
parameter.final.ma <- parameters.est.ma(parameter = parameter.ma, burnin = burnin)
colnames(parameter.final.ma$VaCov) <- colnames(VaCovMa[[1]])
rownames(parameter.final.ma$VaCov) <- rownames(VaCovMa[[1]])
colnames(parameter.final.ma$ranef) <- colnames(result_ranef[[1]])
parameter <- list(coef = resultcoef,
sigmae = result_sigmae,
r2m = result_r2m, r2c = result_r2c,
icc = result_icc)
parameter.final <- parameters.est(parameter = parameter, burnin = burnin)
names(parameter.final$coef) <- rownames(summary(regclass)$coefficients)
formula = o.formula
data = o.data
classes = o.classes
coef = parameter.final$coef
sigmae = parameter.final$sigmae
VaCov = parameter.final.ma$VaCov
nameRI = names(ranef(regclass))
nameRS = names(ranef(regclass)[[1]])[2]
regmodell = regclass
lambda = m.lambda
# Fixed effect prediction to find mu
boot_data <- data
fixedformula <- as.formula(lme4::nobars(formula(regmodell))[-2])
fixedeffect <- model.matrix(fixedformula,data = boot_data)
mu <- as.matrix(fixedeffect) %*% coef
# Get names from FE
name.fe <- names(coef)
# Get name from random intercept
name.RI <- nameRI
# Get name from random  slope
name.RS <- nameRS
# Get name of dependent variable from formula
name.dep <- all.vars(formula)[1]
coef <- NULL
pb <- txtProgressBar(min = 1, max = b, style = 3)
i<-1
p.ranef <- NULL
for (j in 1 :length(unique(boot_data[,tail(all.vars(formula), n=1)]))){
p.ranef <- rbind(p.ranef, apply(rmvnorm(n = 1, mean = rep(0, nrow(VaCov))
,sigma = VaCov), 2,
function(x) {rep(x,table(boot_data[,tail(all.vars(formula), n=1)])[j])}))
}
if(is.na(nameRS)) {boot_data$ynew <- mu + p.ranef[,1] + rnorm(nrow(boot_data), 0 , sigmae)}
if(!is.na(nameRS)) {boot_data$ynew <- mu + p.ranef[,1] + p.ranef[,2]*boot_data[,name.RS]+
rnorm(nrow(boot_data), 0 , sigmae)}
head(boot_data$ynew)
hist(boot_data)
hist(boot_data$ynew)
summary(boot_data$ynew)
rueck <- boxcox.lme.est(dat=boot_data$ynew, lambda = lambda, inverse = T)
str(rueck)
nrow(boot_data)
rueck[[1]]
boot_data$ynew <- rueck[[1]]
##
boot_data$ynew[boot_data$ynew<classes[1]] <- classes[1]+.Machine$double.eps
boot_data$ynew[boot_data$ynew>classes[length(classes)]] <-
classes[length(classes)]+.Machine$double.eps
hist(boot_data$ynew)
assign(paste0("boot_data$",name.dep), cut(boot_data$ynew, classes))
capture.output(SEM <- semLme(formula = formula, data = boot_data,
classes = classes, burnin = burnin, samples = samples,
trafo = trafo, adjust = adjust, bootstrap.se = FALSE))
coef <- rbind(coef, SEM$coef)
coef
library(smicd)
# Run model with random intercept and default settings
data <- Exam
classes <- c(1,1.5,2.5,3.5,4.5,5.5,6.5,7.7,8.5, Inf)
data$examsc.class<- cut(data$examsc, classes)
model1 <- semLme(formula = examsc.class ~ standLRT + schavg + (1|school),
data = data, classes = classes, burnin = 2, samples = 4, bootstrap.se = TRUE, b = 50, trafo = "bc")
summary(model1)
help("semLme")
model1 <- semLme(formula = examsc.class ~ standLRT + schavg + (standLRT|school),
data = data, classes = classes, burnin = 2, samples = 4, bootstrap.se = TRUE, b = 50, trafo = "bc")
summary(model1)
library(smicd)
help(ICD)
devtools::use_travis()
devtools::release()
devtools::release()
check()
devtools::install()
installed.packages("spatstat")
install.packages("spatstat")
install.packages("spatstat")
library(sparstat)
library(spatstat)
devtools::install()
devtools::use_vignette("smicd")
devtools::release()
3
devtools::release()
R.Version()
revdep_check()
devtools::revdep_check()
checks <- readRDS("H:/ICD/revdep/checks.rds")
checks
devtools::release()
use_cran_comments
use_cran_comments()
install.packages("pandoc")
use_cran_comments()
devtools::release()
library(KernSmooth)
toBibtex(KernSmooth)
toBibtex(citation("KernSmooth"))
help(ICD)
library(ICD)
help(ICD)
library(smicd)
library(smicd)
help("semLm")
help("semLme")
help("kdeAlgo")
