for (j in 1:(burnin + samples)) {
new = c()
EstDat = matrix(ncol = 2, nrow = nrow(data))
newWeights = c()
for (i in 1:(length(unique(data$NIntervals)))) {
dataTemp <- data[data$NIntervals == unique(data$NIntervals)[i],]
LBTemp <- unique(dataTemp$LBadj)
UBTemp <- unique(dataTemp$UBadj)
selectionGrid <- gridx[gridx >= LBTemp & gridx < UBTemp]
newWeights <-c(newWeights, dataTemp$weights)
probs = as.vector(Mestimates[gridx%in%selectionGrid])
points = gridx[gridx%in%selectionGrid]
npoints = nrow(dataTemp)
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = "nrd0", adjust = 1)
Mestimates <- NewDensity$y
resultDensity[, j] = Mestimates
resultX[, j] = new
resultW[,j] = newWeights
#EstDat[,1] <- new
#EstDat[,2] <- newWeights
# Hier gleich die Punktschaetzer mit dem Laekenpaket berechnen
#mean <- c(mean, weighted.mean(EstDat[,1], w = EstDat[,2]))
#gin <-  c(gin, (gini(EstDat[,1], weights = EstDat[,2])$value)/100)
#hcr <-  c(hcr, (arpr(EstDat[,1], weights = EstDat[,2], p = 0.6)$value)/100)
#quant10 <-  c(quant10, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.1)))
#quant25 <-  c(quant25, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.25)))
#quant50 <-  c(quant50, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.5)))
#quant75 <-  c(quant75, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.75)))
#quant90 <-  c(quant90, unname(weighted.quantile(EstDat[,1], w = EstDat[,2], probs = 0.9)))
#sw <- sum(EstDat[,2])
#threshold <-  0.6 * weighted.quantile(EstDat[,1],
#                                     w = EstDat[,2],
#                                      probs = .5)
#pgap <- c(pgap,sum(EstDat[,2] * (EstDat[,1] < threshold) * (threshold - EstDat[,1])
#                   / threshold) / sw )
#qsr <- c(qsr, qsr(EstDat[,1], weights = EstDat[,2])$value)
#print(paste("Iteration:", j, "of", burnin + samples))
}
est <- list(Mestimates = Mestimates, resultDensity = resultDensity,
resultX = resultX, xclass = xclass, gridx = gridx, classes = classes,
burnin = burnin, samples = samples, resultW = resultW)
est
is.null(weights)
length(xclass)
rep(1,length(xclass))
load("C:/Users/paulwalter/Desktop/KDE.RData")
oecd <- rep(seq(1,6.9,0.3),25)
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary,
bw = bw, evalpoints = evalpoints, adjust = adjust,
upper = upper, weights = weights, oecd = oecd)
# Internal documentation -------------------------------------------------------
#
# dclassICD
dclassICD <- function (xclass, classes, burnin, samples, boundary,
bw, evalpoints, adjust, upper, weights, oecd)
if(is.null(oecd)){
{
xclassF <- xclass
if (max(classes) == Inf) {
classes[length(classes)] = upper * classes[length(classes) -
1]
}
classmeans <- sapply(1:(length(classes) - 1), function(x) 1/2 *
(classes[x + 1] + classes[x]))
levels(xclass) <- classmeans
lengths = as.vector(table(xclass))
xclass <- as.numeric(as.character(xclass))
gridx = seq(min(classes), max(classes), length = evalpoints)
if (boundary == FALSE) {
Mestimates <- density(xclass, from = min(gridx), to = max(gridx),
n = length(gridx), bw = 2 * max(classes)/length(classes))$y
}
if (boundary == TRUE) {
Mestimates <- dbc(gridx = gridx, x = xclass, bw = 2 *
max(classes)/length(classes))
}
resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(xclass))
resultW = matrix(ncol = c(burnin + samples), nrow = length(xclass))
selectionGrid <- lapply(1:(length(classes) - 1), function(k) {
selection = which(gridx >= classes[k] & gridx < classes[k +
1])
selection
})
if(!is.null(weights)){data <- cbind(xclassF,weights)}
for (j in 1:(burnin + samples)) {
new = c()
newW = c()
for (i in 1:(length(classes) - 1)) {
probs = as.vector(Mestimates[selectionGrid[[i]]])
points = gridx[selectionGrid[[i]]]
npoints = lengths[i]
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
if(!is.null(weights)){newW = c(newW,  data[data[,1]==i,][,2])}
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = bw, adjust = adjust)
Mestimates <- NewDensity$y
if (boundary == TRUE) {
Mestimates <- dbc(gridx = gridx, x = new, bw = NewDensity$bw)
}
resultDensity[,j] = Mestimates
resultX[,j] = new
if(!is.null(weights)){resultW[,j] = newW}
}
if (is.null(weights)){resultW <- NULL}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
} else {
if(is.null(weights)) {weights <- rep(1,length(xclass))}
data <- cbind(xclass, weights, oecd)
LB <- NULL
UB <- NULL
for(i in 1:nrow(data)) {
LB <- c(LB,classes[data[i,1]])
UB <- c(UB,classes[data[i,1]+1])
}
data <- data.frame(xclass, weights, oecd, LB, UB)
data$UB[data$UB == Inf] <- upper * classes[length(classes)-1]
data$LBadj <- data$LB/data$oecd
data$UBadj <- data$UB/data$oecd
data$NIntervals <- paste0(round(data$LBadj, digits = 0), round(data$UBadj,
digits = 0))
data$Mid <- 1/2 * (data$UBadj + data$LBadj)
gridx = seq(min(data$LBadj), max(data$UBadj), length = evalpoints)
Mestimates <- density(data$Mid, from = min(gridx), to = max(gridx),
n = length(gridx), bw = 2 * max(data$UBadj)/
length(unique(data$NIntervals)))$y
resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(data$Mid))
resultW = matrix(ncol = c(burnin + samples), nrow = length(xclass))
for (j in 1:(burnin + samples)) {
new = c()
EstDat = matrix(ncol = 2, nrow = nrow(data))
newWeights = c()
for (i in 1:(length(unique(data$NIntervals)))) {
dataTemp <- data[data$NIntervals == unique(data$NIntervals)[i],]
LBTemp <- unique(dataTemp$LBadj)
UBTemp <- unique(dataTemp$UBadj)
selectionGrid <- gridx[gridx >= LBTemp & gridx < UBTemp]
newWeights <-c(newWeights, dataTemp$weights)
probs = as.vector(Mestimates[gridx%in%selectionGrid])
points = gridx[gridx%in%selectionGrid]
npoints = nrow(dataTemp)
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = "nrd0", adjust = 1)
Mestimates <- NewDensity$y
resultDensity[, j] = Mestimates
resultX[, j] = new
resultW[,j] = newWeights
}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
}
est <- list(Mestimates = Mestimates, resultDensity = resultDensity,
resultX = resultX, xclass = xclass, gridx = gridx, classes = classes,
burnin = burnin, samples = samples, resultW = resultW)
return(est)
}
# Internal documentation -------------------------------------------------------
#
# dclassICD
dclassICD <- function (xclass, classes, burnin, samples, boundary,
bw, evalpoints, adjust, upper, weights, oecd){
if(is.null(oecd)){
xclassF <- xclass
if (max(classes) == Inf) {
classes[length(classes)] = upper * classes[length(classes) -
1]
}
classmeans <- sapply(1:(length(classes) - 1), function(x) 1/2 *
(classes[x + 1] + classes[x]))
levels(xclass) <- classmeans
lengths = as.vector(table(xclass))
xclass <- as.numeric(as.character(xclass))
gridx = seq(min(classes), max(classes), length = evalpoints)
if (boundary == FALSE) {
Mestimates <- density(xclass, from = min(gridx), to = max(gridx),
n = length(gridx), bw = 2 * max(classes)/length(classes))$y
}
if (boundary == TRUE) {
Mestimates <- dbc(gridx = gridx, x = xclass, bw = 2 *
max(classes)/length(classes))
}
resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(xclass))
resultW = matrix(ncol = c(burnin + samples), nrow = length(xclass))
selectionGrid <- lapply(1:(length(classes) - 1), function(k) {
selection = which(gridx >= classes[k] & gridx < classes[k +
1])
selection
})
if(!is.null(weights)){data <- cbind(xclassF,weights)}
for (j in 1:(burnin + samples)) {
new = c()
newW = c()
for (i in 1:(length(classes) - 1)) {
probs = as.vector(Mestimates[selectionGrid[[i]]])
points = gridx[selectionGrid[[i]]]
npoints = lengths[i]
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
if(!is.null(weights)){newW = c(newW,  data[data[,1]==i,][,2])}
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = bw, adjust = adjust)
Mestimates <- NewDensity$y
if (boundary == TRUE) {
Mestimates <- dbc(gridx = gridx, x = new, bw = NewDensity$bw)
}
resultDensity[,j] = Mestimates
resultX[,j] = new
if(!is.null(weights)){resultW[,j] = newW}
}
if (is.null(weights)){resultW <- NULL}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
} else {
if(is.null(weights)) {weights <- rep(1,length(xclass))}
data <- cbind(xclass, weights, oecd)
LB <- NULL
UB <- NULL
for(i in 1:nrow(data)) {
LB <- c(LB,classes[data[i,1]])
UB <- c(UB,classes[data[i,1]+1])
}
data <- data.frame(xclass, weights, oecd, LB, UB)
data$UB[data$UB == Inf] <- upper * classes[length(classes)-1]
data$LBadj <- data$LB/data$oecd
data$UBadj <- data$UB/data$oecd
data$NIntervals <- paste0(round(data$LBadj, digits = 0), round(data$UBadj,
digits = 0))
data$Mid <- 1/2 * (data$UBadj + data$LBadj)
gridx = seq(min(data$LBadj), max(data$UBadj), length = evalpoints)
Mestimates <- density(data$Mid, from = min(gridx), to = max(gridx),
n = length(gridx), bw = 2 * max(data$UBadj)/
length(unique(data$NIntervals)))$y
resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(data$Mid))
resultW = matrix(ncol = c(burnin + samples), nrow = length(xclass))
for (j in 1:(burnin + samples)) {
new = c()
EstDat = matrix(ncol = 2, nrow = nrow(data))
newWeights = c()
for (i in 1:(length(unique(data$NIntervals)))) {
dataTemp <- data[data$NIntervals == unique(data$NIntervals)[i],]
LBTemp <- unique(dataTemp$LBadj)
UBTemp <- unique(dataTemp$UBadj)
selectionGrid <- gridx[gridx >= LBTemp & gridx < UBTemp]
newWeights <-c(newWeights, dataTemp$weights)
probs = as.vector(Mestimates[gridx%in%selectionGrid])
points = gridx[gridx%in%selectionGrid]
npoints = nrow(dataTemp)
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = "nrd0", adjust = 1)
Mestimates <- NewDensity$y
resultDensity[, j] = Mestimates
resultX[, j] = new
resultW[,j] = newWeights
}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
}
est <- list(Mestimates = Mestimates, resultDensity = resultDensity,
resultX = resultX, xclass = xclass, gridx = gridx, classes = classes,
burnin = burnin, samples = samples, resultW = resultW)
return(est)
}
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary,
bw = bw, evalpoints = evalpoints, adjust = adjust,
upper = upper, weights = weights, oecd = oecd)
Indicators.run <- NULL
for (i in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
# Internal documentation -------------------------------------------------------
# The function estimates the pre-defined indicators
indicators.est <- function(x,threshold, custom_indicator, weights) {
if (is.null(weights)) {
if(is.na(threshold)) {
threshold <- 0.6*median(x)
} else {
threshold <- threshold*median(x)
}
results <- c(mean = mean(x),
gini = ineq(x),
hcr = mean(x<threshold),
quant10 = unname(quantile(x, probs = c(0.1))),
quant25 = unname(quantile(x, probs = c(0.25))),
quant50 = unname(quantile(x, probs = c(0.50))),
quant75 = unname(quantile(x, probs = c(0.75))),
quant90 = unname(quantile(x, probs = c(0.90))) ,
pgap = mean((x<threshold)*(threshold-x)/threshold),
qsr = sum(x[(x>quantile(x,0.8))])/sum(x[(x<quantile(x,0.2))])
)
if (!is.null(custom_indicator)){
c.indicator <- NULL
for(i in 1:length(custom_indicator)) {
c.indicator <- c(c.indicator, custom_indicator[[i]](x, threshold))
}
names(c.indicator) <- names(custom_indicator)
results <- c(results, c.indicator)
}
} else {
sw <- sum(weights)
thresholdW <-  threshold * weighted.quantile(x,
w = weights,
probs = .5)
results <- c(mean = weighted.mean(x, w = weights),
gini =  gini(x, weights = weights)$value/100,
hcr =  arpr(x, weights = weights, p = threshold)$value/100,
quant10 =  unname(weighted.quantile(x, w = weights, probs = 0.1)),
quant25 =  unname(weighted.quantile(x, w = weights, probs = 0.25)),
quant50 =  unname(weighted.quantile(x, w = weights, probs = 0.5)),
quant75 =  unname(weighted.quantile(x, w = weights, probs = 0.75)),
quant90 =  unname(weighted.quantile(x, w = weights, probs = 0.9)),
pgap = sum(weights * (x < thresholdW) * (thresholdW - x)
/ thresholdW) / sw,
qsr = qsr(x, weights = weights)$value)
if (!is.null(custom_indicator)){
c.indicator <- NULL
for(i in 1:length(custom_indicator)) {
c.indicator <- c(c.indicator, custom_indicator[[i]](x, threshold, weights))
}
names(c.indicator) <- names(custom_indicator)
results <- c(results, c.indicator)
}
}
return(results)
}
for (i in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
weights <- abs(weights)
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary,
bw = bw, evalpoints = evalpoints, adjust = adjust,
upper = upper, weights = weights, oecd = oecd)
for (i in 1:dim(density.est$resultX)[2]) {
Indicators.run <- cbind(Indicators.run,indicators.est(x=density.est$resultX[,i],
threshold = threshold,
custom_indicator = custom_indicator,
weights = density.est$resultW[,i]))
}
Indicators.run
Indicators <- rowMeans(Indicators.run)
Indicators
str(density.est)
oecd <- NULL
weights <- NULL
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary,
bw = bw, evalpoints = evalpoints, adjust = adjust,
upper = upper, weights = weights, oecd = oecd)
str(density.est)
# Internal documentation -------------------------------------------------------
#
# dclassICD
dclassICD <- function (xclass, classes, burnin, samples, boundary,
bw, evalpoints, adjust, upper, weights, oecd){
if(is.null(oecd)){
xclassF <- xclass
if (max(classes) == Inf) {
classes[length(classes)] = upper * classes[length(classes) -
1]
}
classmeans <- sapply(1:(length(classes) - 1), function(x) 1/2 *
(classes[x + 1] + classes[x]))
levels(xclass) <- classmeans
lengths = as.vector(table(xclass))
xclass <- as.numeric(as.character(xclass))
gridx = seq(min(classes), max(classes), length = evalpoints)
if (boundary == FALSE) {
Mestimates <- density(xclass, from = min(gridx), to = max(gridx),
n = length(gridx), bw = 2 * max(classes)/length(classes))$y
}
if (boundary == TRUE) {
Mestimates <- dbc(gridx = gridx, x = xclass, bw = 2 *
max(classes)/length(classes))
}
resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(xclass))
resultW = matrix(ncol = c(burnin + samples), nrow = length(xclass))
selectionGrid <- lapply(1:(length(classes) - 1), function(k) {
selection = which(gridx >= classes[k] & gridx < classes[k +
1])
selection
})
if(!is.null(weights)){data <- cbind(xclassF,weights)}
for (j in 1:(burnin + samples)) {
new = c()
newW = c()
for (i in 1:(length(classes) - 1)) {
probs = as.vector(Mestimates[selectionGrid[[i]]])
points = gridx[selectionGrid[[i]]]
npoints = lengths[i]
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
if(!is.null(weights)){newW = c(newW,  data[data[,1]==i,][,2])}
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = bw, adjust = adjust)
Mestimates <- NewDensity$y
if (boundary == TRUE) {
Mestimates <- dbc(gridx = gridx, x = new, bw = NewDensity$bw)
}
resultDensity[,j] = Mestimates
resultX[,j] = new
if(!is.null(weights)){resultW[,j] = newW}
}
if (is.null(weights)){resultW <- NULL}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
} else {
if(is.null(weights)) {weights <- rep(1,length(xclass))}
data <- cbind(xclass, weights, oecd)
LB <- NULL
UB <- NULL
for(i in 1:nrow(data)) {
LB <- c(LB,classes[data[i,1]])
UB <- c(UB,classes[data[i,1]+1])
}
data <- data.frame(xclass, weights, oecd, LB, UB)
data$UB[data$UB == Inf] <- upper * classes[length(classes)-1]
data$LBadj <- data$LB/data$oecd
data$UBadj <- data$UB/data$oecd
data$NIntervals <- paste0(round(data$LBadj, digits = 0), round(data$UBadj,
digits = 0))
data$Mid <- 1/2 * (data$UBadj + data$LBadj)
gridx = seq(min(data$LBadj), max(data$UBadj), length = evalpoints)
Mestimates <- density(data$Mid, from = min(gridx), to = max(gridx),
n = length(gridx), bw = 2 * max(data$UBadj)/
length(unique(data$NIntervals)))$y
resultDensity = matrix(ncol = c(burnin + samples), nrow = length(gridx))
resultX = matrix(ncol = c(burnin + samples), nrow = length(data$Mid))
resultW = matrix(ncol = c(burnin + samples), nrow = length(xclass))
for (j in 1:(burnin + samples)) {
new = c()
EstDat = matrix(ncol = 2, nrow = nrow(data))
newWeights = c()
for (i in 1:(length(unique(data$NIntervals)))) {
dataTemp <- data[data$NIntervals == unique(data$NIntervals)[i],]
LBTemp <- unique(dataTemp$LBadj)
UBTemp <- unique(dataTemp$UBadj)
selectionGrid <- gridx[gridx >= LBTemp & gridx < UBTemp]
newWeights <-c(newWeights, dataTemp$weights)
probs = as.vector(Mestimates[gridx%in%selectionGrid])
points = gridx[gridx%in%selectionGrid]
npoints = nrow(dataTemp)
new = c(new, points[sample(1:length(points), size = npoints,
replace = T, prob = probs)])
}
NewDensity <- density(new, from = min(gridx), to = max(gridx),
n = length(gridx), bw = "nrd0", adjust = 1)
Mestimates <- NewDensity$y
resultDensity[, j] = Mestimates
resultX[, j] = new
if(is.null(weights)){resultW <- NULL} else {
resultW[,j] = newWeights}
}
Mestimates = apply(resultDensity[, -c(1:burnin)], c(1), mean)
}
est <- list(Mestimates = Mestimates, resultDensity = resultDensity,
resultX = resultX, xclass = xclass, gridx = gridx, classes = classes,
burnin = burnin, samples = samples, resultW = resultW)
return(est)
}
density.est <- dclassICD(xclass = xclass, classes = classes,
burnin = burnin, samples = samples, boundary = boundary,
bw = bw, evalpoints = evalpoints, adjust = adjust,
upper = upper, weights = weights, oecd = oecd)
str(density.est)
library(ICD)
library(ICD)
example("semLm")
plot(semLM)
plot(model)
example("semLme")
plot(semLME)
plot(model)
plot(model1)
plot(model2)
summary(model2)
install.packages("ISLR")
hitters
library(ISLR)
hitters
?ISLR
??ISLR
?MASS
?Kernelheaping
help(Kernelheaping)
help("ICD-package")
help("ISLR-package")
Hitters
data <- Hitters
save.image("C:/Users/paulwalter/Desktop/Hitters.RData")
head(data)
